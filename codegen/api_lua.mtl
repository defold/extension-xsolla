local log = require("xsolla.util.log")
local net = require("xsolla.util.net")
local uri = require("xsolla.util.uri")
local async = require("xsolla.util.async")
local retries = require("xsolla.util.retries")

local M = {}

local SERVERS = {
    {{#servers}}
    "{{url}}",
    {{/servers}}
}


local config = {
    http_uri = SERVERS[1],
    bearer_token = nil,
    username = nil,
    password = nil,
    timeout = 3,    -- seconds
    retry_policy = retries.fixed(5, 0.5),
}

-- cancellation tokens associated with a coroutine
local cancellation_tokens = {}

-- cancel a cancellation token
function M.cancel(token)
    assert(token)
    token.cancelled = true
end

-- create a cancellation token
-- use this to cancel an ongoing API call or a sequence of API calls
-- @return token Pass the token to a call to xsolla.sync() or to any of the API calls
function M.cancellation_token()
    local token = {
        cancelled = false
    }
    function token.cancel()
        token.cancelled = true
    end
    return token
end

function M.set_bearer_token(bearer_token)
    config.bearer_token = bearer_token
end

-- Private
-- Run code within a coroutine
-- @param fn The code to run
-- @param cancellation_token Optional cancellation token to cancel the running code
function M.sync(fn, cancellation_token)
    assert(fn)
    local ok, err
    local co = coroutine.running()
    if co then
        ok, err = pcall(function()
            cancellation_tokens[co] = cancellation_token
            fn()
            cancellation_tokens[co] = nil
        end)
    else
        co = coroutine.create(function()
            cancellation_tokens[co] = cancellation_token
            fn()
            cancellation_tokens[co] = nil
        end)
        ok, err = coroutine.resume(co)
    end
    if not ok then
        log(err)
        cancellation_tokens[co] = nil
    end
end

-- http request helper used to reduce code duplication in all API functions below
local function http(callback, url_path, query_params, method, post_data, retry_policy, cancellation_token, handler_fn)
    if callback then
        log(url_path, "with callback")
        net.http(config, url_path, query_params, method, post_data, retry_policy, cancellation_token, function(result)
            if not cancellation_token or not cancellation_token.cancelled then
                if result.error then
                    callback(handler_fn(false, result))
                else
                    callback(handler_fn(result))
                end
            end
        end)
    else
        log(url_path, "with coroutine")
        local co = coroutine.running()
        assert(co, "You must be running this from within a coroutine")

        -- get cancellation token associated with this coroutine
        cancellation_token = cancellation_tokens[co]
        if cancellation_token and cancellation_token.cancelled then
            cancellation_tokens[co] = nil
            return
        end

        return async(function(done)
            net.http(config, url_path, query_params, method, post_data, retry_policy, cancellation_token, function(result)
                if cancellation_token and cancellation_token.cancelled then
                    cancellation_tokens[co] = nil
                    return
                end
                if result.error then
                    done(handler_fn(false, result))
                else
                    done(handler_fn(result))
                end
            end)
        end)
    end
end

{{#components}}
{{#requestBodies}}

--- Create {{id}} data structure
-- @param t Table with properties.{{#content}}{{#application/json}}{{#schema}}{{^oneof}} Acceptable table keys:{{/oneof}}{{/schema}}{{/application/json}}{{/content}}
{{#schema}}
{{#properties}}
--   * {{id}} - [{{type}}] {{{description}}}
{{#array}}
{{#items}}
{{#object}}
{{.}}
{{/object}}
{{/items}}
{{/array}}
{{/properties}}
{{/schema}}
-- @example
{{{example}}}
function M.body_{{id}}(t)
    assert(t)
{{#schema}}
{{#required}}
    assert(t.{{.}})
{{/required}}
{{/schema}}
{{#schema}}
    {{#oneof}}
    return json.encode(t)
    {{/oneof}}
    {{^oneof}}
    return json.encode({
        {{#properties}}
        ["{{id}}"] = t.{{id}},
        {{/properties}}
    })
    {{/oneof}}
{{/schema}}
end

{{/requestBodies}}
{{/components}}

{{#paths}}

--- {{summary}}
-- {{description}}
-- {{path}}
-- @name {{operationId}}
{{#parameters}}
-- @param {{name}} {{#required}}(REQUIRED) {{/required}}{{description}}
{{/parameters}}
{{#requestBody}}
-- @param body Create using body_{{id}}()
{{/requestBody}}
-- @param callback
-- @param retry_policy
-- @param cancellation_token
function M.{{operationId}}({{#parameters}}{{name}}, {{/parameters}}{{#requestBody}}body, {{/requestBody}}callback, retry_policy, cancellation_token)
    {{#requestBody}}
    assert(body)
    {{/requestBody}}
    {{#parameters}}
    {{#required}}
    assert({{name}})
    {{/required}}
    {{/parameters}}

    local url_path = "{{ path }}"
    {{#parameters}}
    {{#inpath}}
    url_path = url_path:gsub("%7B{{name}}%7D", uri.encode(tostring({{name}})))
    {{/inpath}}
    {{/parameters}}

    local query_params = {}
    {{#parameters}}
    {{#inquery}}
    query_params["{{name}}"] = {{name}}
    {{/inquery}}
    {{/parameters}}

    local post_data = {{#requestBody}}body{{/requestBody}}{{^requestBody}}nil{{/requestBody}}

    return http(callback, url_path, query_params, "{{method}}", post_data, retry_policy, cancellation_token, function(result, err)
        return result, err
    end)
end
{{/paths}}

return M